(()=>{"use strict";const e=new class{constructor(){this.api="undefined"!=typeof chrome&&chrome.runtime?chrome:browser}handleRuntimeError(e,t,a){this.api.runtime.lastError?t(new Error(this.api.runtime.lastError.message)):e(a)}get isChrome(){return"undefined"!=typeof chrome&&!!chrome.runtime}get isFirefox(){return!this.isChrome&&"undefined"!=typeof browser&&!!browser.runtime}get manifestVersion(){return this.api.runtime.getManifest().manifest_version}get storage(){return{get:e=>new Promise((t,a)=>{this.api.storage.local.get(e,e=>{this.handleRuntimeError(t,a,e)})}),set:e=>new Promise((t,a)=>{this.api.storage.local.set(e,()=>{this.handleRuntimeError(t,a,void 0)})}),remove:e=>new Promise((t,a)=>{this.api.storage.local.remove(e,()=>{this.handleRuntimeError(t,a,void 0)})})}}get runtime(){return{sendMessage:e=>new Promise(t=>{this.api.runtime.sendMessage(e,e=>{t(e)})}),onMessage:this.api.runtime.onMessage,getManifest:()=>this.api.runtime.getManifest(),openOptionsPage:()=>this.api.runtime.openOptionsPage()}}get tabs(){return{query:e=>new Promise(t=>{this.api.tabs.query(e,t)}),sendMessage:(e,t)=>new Promise(a=>{this.api.tabs.sendMessage(e,t,e=>{a(e)})})}}get commands(){return{onCommand:this.api.commands.onCommand}}},t={openRouterApiKey:void 0,targetLanguage:"ja",fontSize:16,lineHeight:1.5,darkMode:!1,openRouterModel:"",schemaVersion:3,selectionFontSize:14},a=class{async get(a){try{console.log("[StorageManager] get() called with keys:",a);const n=a?await e.storage.get(a):await e.storage.get([]);console.log("[StorageManager] Raw data from BrowserAdapter:",n),console.log("[StorageManager] Data keys:",Object.keys(n)),console.log("[StorageManager] openRouterApiKey:",n.openRouterApiKey),console.log("[StorageManager] openRouterModel:",n.openRouterModel),n.lineHeight&&n.lineHeight>2&&(n.lineHeight=1.5,await this.set({lineHeight:1.5}));const r={...t,...n};return console.log("[StorageManager] Merged result:",r),console.log("[StorageManager] Result openRouterApiKey:",r.openRouterApiKey),console.log("[StorageManager] Result openRouterModel:",r.openRouterModel),r}catch(e){return console.error("[StorageManager] get error:",e),console.error("[StorageManager] Returning DEFAULT_STORAGE due to error"),t}}async set(t){try{await e.storage.set(t)}catch(e){throw console.error("StorageManager.set error:",e),e}}async remove(t){try{await e.storage.remove(t)}catch(e){throw console.error("StorageManager.remove error:",e),e}}async clear(){try{const e="undefined"!=typeof chrome?chrome:browser;return new Promise(t=>{e.storage.local.clear(()=>{t()})})}catch(e){throw console.error("StorageManager.clear error:",e),e}}async getApiKey(){try{return(await this.get(["openRouterApiKey"])).openRouterApiKey||null}catch(e){return console.error("StorageManager.getApiKey error:",e),null}}async setApiKey(e){try{await this.set({openRouterApiKey:e})}catch(e){throw console.error("StorageManager.setApiKey error:",e),e}}async getTargetLanguage(){try{return(await this.get(["targetLanguage"])).targetLanguage||t.targetLanguage}catch(e){return console.error("StorageManager.getTargetLanguage error:",e),t.targetLanguage}}async setTargetLanguage(e){try{await this.set({targetLanguage:e})}catch(e){throw console.error("StorageManager.setTargetLanguage error:",e),e}}};function n(e){return`${function(){const e=new Date;return`${e.getFullYear()}-${String(e.getMonth()+1).padStart(2,"0")}-${String(e.getDate()).padStart(2,"0")} ${String(e.getHours()).padStart(2,"0")}:${String(e.getMinutes()).padStart(2,"0")}:${String(e.getSeconds()).padStart(2,"0")}`}()} [${e}]`}const r={log(e,...t){},warn(e,...t){const a=n("WARN");console.warn(`${a} ${e}`,...t)},error(e,...t){const a=n("ERROR");console.error(`${a} ${e}`,...t)}};async function s(e,t){const{maxRetries:a,delay:n,backoff:r="exponential",onError:s}=t;let o;for(let t=0;t<=a;t++)try{return await e()}catch(e){if(o=e,s&&t<a&&s(o,t),t<a){const e="exponential"===r?n*Math.pow(2,t):n*(t+1);await new Promise(t=>setTimeout(t,e))}}throw o}const o="exponential",i=new Map([{code:"en",name:"English",nameEn:"English"},{code:"ja",name:"日本語",nameEn:"Japanese"},{code:"zh",name:"中文",nameEn:"Chinese (Simplified)"},{code:"zh-TW",name:"中文 (繁體)",nameEn:"Chinese (Traditional)"},{code:"ko",name:"한국어",nameEn:"Korean"},{code:"es",name:"Español",nameEn:"Spanish"},{code:"fr",name:"Français",nameEn:"French"},{code:"de",name:"Deutsch",nameEn:"German"},{code:"it",name:"Italiano",nameEn:"Italian"},{code:"pt",name:"Português",nameEn:"Portuguese"},{code:"ru",name:"Русский",nameEn:"Russian"},{code:"ar",name:"العربية",nameEn:"Arabic"},{code:"hi",name:"हिन्दी",nameEn:"Hindi"},{code:"th",name:"ไทย",nameEn:"Thai"},{code:"vi",name:"Tiếng Việt",nameEn:"Vietnamese"},{code:"id",name:"Bahasa Indonesia",nameEn:"Indonesian"},{code:"tr",name:"Türkçe",nameEn:"Turkish"},{code:"pl",name:"Polski",nameEn:"Polish"},{code:"nl",name:"Nederlands",nameEn:"Dutch"},{code:"sv",name:"Svenska",nameEn:"Swedish"}].map(e=>[e.code,e]));class c extends Error{constructor(e,t,a=!1){super(e),this.statusCode=t,this.isRateLimitError=a,this.name="ApiError"}}class l extends Error{constructor(e="Request timeout"){super(e),this.name="TimeoutError"}}class g{constructor(){this.API_ENDPOINT="https://openrouter.ai/api/v1/chat/completions",this.TEXT_SEPARATOR="---NEXT-TEXT---",this.config=null,this.PROMPT_PATTERNS=[/^Translate the following texts? to \w+\.?\s*/i,/^IMPORTANT INSTRUCTIONS:[\s\S]*?---NEXT-TEXT---\s*/i,/Texts? (?:are|is) separated by ["']---NEXT-TEXT---["']\.?\s*/i,/Return translations? in the same format,? separated by ["']---NEXT-TEXT---["'][\s:]*\n?/i,/[|「」]?で区切られていること[^。]*?[|「]/g,/翻訳も同じ形式で[^。]*?[|「]/g,/テキストは[\s\S]*?で区切られています\.?\s*/g,/\|」で区切られていること\s*-\s*翻訳も同じ形式で、「\|[^|]*\|/g,/\s*\|[前後]へ\|/g,/\s*\|親\s*\|/g,/\s*\|root\|/gi,/親\s*\|/g,/\s*\|[^|]{1,10}\|\s*$/g]}async initialize(){console.log("[OpenRouterClient] initialize() called");const e=new a,t=await e.get(["openRouterApiKey","openRouterModel","openRouterProvider"]);console.log("[OpenRouterClient] Data received from StorageManager:",t),console.log("[OpenRouterClient] openRouterApiKey exists:",!!t.openRouterApiKey),console.log("[OpenRouterClient] openRouterApiKey value:",t.openRouterApiKey),console.log("[OpenRouterClient] openRouterModel exists:",!!t.openRouterModel),console.log("[OpenRouterClient] openRouterModel value:",t.openRouterModel),this.config={apiKey:t.openRouterApiKey||"",model:t.openRouterModel||"",provider:t.openRouterProvider},console.log("[OpenRouterClient] Config set to:",this.config)}async translate(e,t){const a=(new Date).toISOString();if(console.log(`[Background:OpenRouterClient] ${a} - translate() called:`,{textsCount:e.length,targetLanguage:t,firstText:e[0]?.substring(0,50)}),this.config||(console.log(`[Background:OpenRouterClient] ${a} - Config not loaded, initializing...`),await this.initialize()),console.log(`[Background:OpenRouterClient] ${a} - Using config:`,{hasApiKey:!!this.config?.apiKey,apiKeyPrefix:this.config?.apiKey?.substring(0,10)+"...",model:this.config?.model,provider:this.config?.provider}),!this.config?.apiKey||""===this.config.apiKey.trim())throw console.error(`[Background:OpenRouterClient] ${a} - API key not configured or empty`),new Error("API key not configured or empty");if(!this.config?.model||""===this.config.model.trim())throw console.error(`[Background:OpenRouterClient] ${a} - Model not configured or empty`),new Error("Model not configured or empty. Please specify a model in the settings.");return s(async()=>{const n=this.buildPrompt(e,t);console.log(`[Background:OpenRouterClient] ${a} - Built prompt (first 100 chars):`,{prompt:n.substring(0,100)});const s={model:this.config.model,messages:[{role:"user",content:n}]};this.config.provider&&(s.provider={order:[this.config.provider]}),console.log(`[Background:OpenRouterClient] ${a} - Making API request:`,{endpoint:this.API_ENDPOINT,model:this.config.model,hasProvider:!!this.config.provider});const o=await this.fetchWithTimeout(this.API_ENDPOINT,{method:"POST",headers:{Authorization:`Bearer ${this.config.apiKey}`,"Content-Type":"application/json","HTTP-Referer":"https://github.com/doganaylab/geminitranslate"},body:JSON.stringify(s)});if(console.log(`[Background:OpenRouterClient] ${a} - Received API response:`,{status:o.status,statusText:o.statusText,ok:o.ok}),!o.ok){const e=await o.json(),t=429===o.status;throw console.error(`[Background:OpenRouterClient] ${a} - API request failed:`,{status:o.status,statusText:o.statusText,error:e,isRateLimit:t}),r.error("OpenRouter API error:",e),new c(`API request failed: ${e.error?.message||o.statusText}`,o.status,t)}const i=await o.json();console.log(`[Background:OpenRouterClient] ${a} - Parsing API response:`,{hasChoices:!!i.choices,choicesLength:i.choices?.length,hasContent:!!i.choices?.[0]?.message?.content});const l=this.parseResponse(i.choices[0].message.content,e.length);return console.log(`[Background:OpenRouterClient] ${a} - Translation successful:`,{translationsCount:l.length,firstTranslation:l[0]?.substring(0,50)}),l},{maxRetries:3,delay:1e3,backoff:o,onError:(e,t)=>{console.warn(`[Background:OpenRouterClient] ${a} - Retry attempt ${t+1}:`,{error:e.message,attempt:t}),r.warn(`Translation attempt ${t+1} failed:`,e.message)}})}async fetchWithTimeout(e,t){const a=new AbortController,n=setTimeout(()=>a.abort(),3e4);try{const r=await fetch(e,{...t,signal:a.signal});return clearTimeout(n),r}catch(e){if(clearTimeout(n),"AbortError"===e.name)throw new l("Request timed out after 30000ms");throw e}}buildPrompt(e,t){const a=function(e,t=!0){const a=i.get(e);return a?t?a.name:a.nameEn:e}(t,!1),n=e.join(`\n${this.TEXT_SEPARATOR}\n`);return`Translate the following texts to ${a}.\n\nIMPORTANT INSTRUCTIONS:\n- Return ONLY the translation, NOT the original text\n- Do NOT include both original and translation (no side-by-side format)\n- Translate the COMPLETE text, do NOT summarize or shorten\n- Preserve ALL information, sentences, and paragraphs\n- Maintain the original length and detail level\n- Each text is independent - translate them separately\n- Texts are separated by "${this.TEXT_SEPARATOR}"\n- Return translations in the same format, separated by "${this.TEXT_SEPARATOR}"\n\n${n}`}removePromptArtifacts(e){let t=e;for(const e of this.PROMPT_PATTERNS)t=t.replace(e,"");return t.trim()}splitWithoutSeparator(e,t){if(1===t)return[e.trim()];const a=e.split(/\n\n+/).map(e=>e.trim()).filter(e=>e);if(a.length===t)return r.log("Split by paragraph breaks matched expected count"),a;const n=e.split(/\n/).map(e=>e.trim()).filter(e=>e);return n.length===t?(r.log("Split by line breaks matched expected count"),n):a.length>1&&Math.abs(a.length-t)<Math.abs(n.length-t)?(r.warn(`Using paragraph split (${a.length}) as fallback, expected ${t}`),a):n.length>1?(r.warn(`Using line split (${n.length}) as fallback, expected ${t}`),n):(r.warn(`Could not split response into ${t} parts, returning as single translation`),[e.trim()])}parseResponse(e,t){const a=this.removePromptArtifacts(e);if(a.includes(this.TEXT_SEPARATOR)){const e=a.split(this.TEXT_SEPARATOR).map(e=>e.trim()).filter(e=>e);if(e.length===t)return e;if(e.length>0)return r.warn(`Separator split: expected ${t} translations, got ${e.length}`),e}return r.log("No separator found in response, using fallback splitting"),this.splitWithoutSeparator(a,t)}async testConnection(){try{return this.config||await this.initialize(),this.config?.apiKey&&""!==this.config.apiKey.trim()?(await this.translate(["Hello"],"Japanese"),{success:!0,message:`Connection successful! Model: ${this.config?.model}`}):{success:!1,error:"API key is required. Please configure your OpenRouter API key."}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async testConnectionWithConfig(e){try{if(!e.apiKey||""===e.apiKey.trim())return{success:!1,error:"API key is required. Please configure your OpenRouter API key."};if(!e.model||""===e.model.trim())return{success:!1,error:"Model is required. Please specify a model in the settings."};const t=this.config;this.config={apiKey:e.apiKey,model:e.model,provider:e.provider};try{return await this.translate(["Hello"],"Japanese"),{success:!0,message:`Connection successful! Model: ${this.config.model}`}}finally{this.config=t}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}}const h=class{constructor(e=1e3){this.cache=new Map,this.maxSize=e}get(e){const t=this.cache.get(e);return t?(this.cache.delete(e),t.timestamp=Date.now(),this.cache.set(e,t),t.value):null}set(e,t){if(this.cache.has(e)&&this.cache.delete(e),this.cache.size>=this.maxSize){const e=this.cache.keys().next().value;void 0!==e&&this.cache.delete(e)}this.cache.set(e,{value:t,timestamp:Date.now()})}has(e){return this.cache.has(e)}delete(e){return this.cache.delete(e)}clear(){this.cache.clear()}size(){return this.cache.size}keys(){return Array.from(this.cache.keys())}getStats(){return{size:this.cache.size,maxSize:this.maxSize,usage:this.cache.size/this.maxSize*100}}evictOlderThan(e){const t=Date.now();let a=0;for(const[n,r]of this.cache.entries())t-r.timestamp>e&&(this.cache.delete(n),a++);return a}};class d{constructor(){this.memoryCache=new h(1e3),this.BATCH_SIZE=100,this.cacheHits=0,this.cacheMisses=0,this.initialized=!1,this.apiClient=new g}async initialize(){this.initialized||(await this.apiClient.initialize(),this.initialized=!0,r.log("TranslationEngine initialized"))}async translateBatchSemiParallel(e,t,a=1,n){const s=(new Date).toISOString();if(console.log(`[Background:TranslationEngine] ${s} - translateBatchSemiParallel() called:`,{textsCount:e.length,targetLanguage:t,priorityCount:a}),!this.initialized)throw new Error("TranslationEngine not initialized. Call initialize() first.");if(0===e.length)return[];const o=new Array(e.length),i=[];for(let a=0;a<e.length;a++){const n=await this.getCachedTranslation(e[a],t);n?(o[a]=n,this.cacheHits++):(i.push(a),this.cacheMisses++)}if(0===i.length){if(n&&e.length>0)try{const t=Array.from({length:e.length},(e,t)=>t);n(0,o,t)}catch(e){r.warn("Batch complete callback error (cache hit):",e)}return o}const c=i.map(t=>e[t]),l=this.chunkArray(c,this.BATCH_SIZE),g=l.slice(0,a),h=l.slice(a);console.log(`[Background:TranslationEngine] ${s} - Semi-parallel: ${g.length} sequential, ${h.length} parallel`);let d=[],u=0;for(let e=0;e<g.length;e++){const a=g[e],s=await this.translateWithRetry(a,t);if(d.push(...s),n)try{const t=i.slice(u,u+a.length);n(e,s,t)}catch(t){r.warn(`Batch complete callback error (batch ${e}):`,t)}u+=a.length}if(h.length>0){const e=h.map(e=>this.translateWithRetry(e,t));(await Promise.all(e)).forEach((e,t)=>{const a=g.length+t;if(d.push(...e),n)try{const t=i.slice(u,u+e.length);n(a,e,t)}catch(e){r.warn(`Batch complete callback error (batch ${a}):`,e)}u+=e.length})}for(let a=0;a<i.length;a++){const n=i[a],r=d[a];o[n]=r,await this.setCachedTranslation(e[n],t,r)}return o}async translateBatch(e,t,a){if(a?.semiParallel)return this.translateBatchSemiParallel(e,t,a.priorityCount);const n=(new Date).toISOString();if(console.log(`[Background:TranslationEngine] ${n} - translateBatch() called:`,{textsCount:e.length,targetLanguage:t,firstText:e[0]?.substring(0,50)}),!this.initialized)throw console.error(`[Background:TranslationEngine] ${n} - Engine not initialized`),new Error("TranslationEngine not initialized. Call initialize() first.");if(0===e.length)return console.log(`[Background:TranslationEngine] ${n} - Empty input, returning empty array`),[];const r=new Array(e.length),s=[];console.log(`[Background:TranslationEngine] ${n} - Checking cache for ${e.length} texts...`);for(let a=0;a<e.length;a++){const n=await this.getCachedTranslation(e[a],t);n?(r[a]=n,this.cacheHits++):(s.push(a),this.cacheMisses++)}if(console.log(`[Background:TranslationEngine] ${n} - Cache check complete:`,{cacheHits:this.cacheHits,cacheMisses:this.cacheMisses,uncachedCount:s.length}),s.length>0){const a=s.map(t=>e[t]),o=this.chunkArray(a,this.BATCH_SIZE);console.log(`[Background:TranslationEngine] ${n} - Translating ${s.length} uncached texts in ${o.length} batches`);const i=await Promise.all(o.map((e,a)=>(console.log(`[Background:TranslationEngine] ${n} - Processing batch ${a+1}/${o.length}:`,{batchSize:e.length}),this.translateWithRetry(e,t))));console.log(`[Background:TranslationEngine] ${n} - All batches processed`);const c=i.flat();console.log(`[Background:TranslationEngine] ${n} - Flattened translations:`,{count:c.length});for(let a=0;a<s.length;a++){const n=s[a],o=c[a];r[n]=o,await this.setCachedTranslation(e[n],t,o)}console.log(`[Background:TranslationEngine] ${n} - Cache updated with new translations`)}return console.log(`[Background:TranslationEngine] ${n} - translateBatch() completed:`,{resultsCount:r.length,firstResult:r[0]?.substring(0,50)}),r}async getCachedTranslation(e,t){const a=this.getCacheKey(e,t),n=this.getFromMemoryCache(a);if(n)return n;const r=this.getFromStorage(sessionStorage,a);if(r)return this.promoteToMemoryCache(a,r),r;const s=this.getFromStorage(localStorage,a);return s?(this.promoteToHigherTiers(a,s),s):null}getFromMemoryCache(e){return this.memoryCache.get(e)||null}getFromStorage(e,t){try{const a=e.getItem(t);if(a)return JSON.parse(a).translation}catch(e){r.warn(`Storage read error for key ${t}:`,e)}return null}promoteToMemoryCache(e,t){this.memoryCache.set(e,t)}promoteToHigherTiers(e,t){this.memoryCache.set(e,t);const a={text:e.split(":")[1],translation:t};this.saveToStorage(sessionStorage,e,a)}async setCachedTranslation(e,t,a){const n=this.getCacheKey(e,t),r={text:e,translation:a};this.memoryCache.set(n,a),this.saveToStorage(sessionStorage,n,r),this.saveToStorage(localStorage,n,r)}saveToStorage(e,t,a){try{e.setItem(t,JSON.stringify(a))}catch(e){r.warn(`Storage write error for key ${t}:`,e)}}getCacheKey(e,t){return`translation:${e}:${t}`}async translateWithRetry(e,t){return s(async()=>this.apiClient.translate(e,t),{maxRetries:3,delay:1e3,backoff:o,onError:(e,t)=>{r.warn(`Translation retry attempt ${t+1}:`,e.message)}})}async clearCache(e="all"){switch(e){case"memory":this.memoryCache.clear(),r.log("Memory cache cleared");break;case"session":this.clearStorageCache(sessionStorage,"Session storage");break;case"local":this.clearStorageCache(localStorage,"Local storage");break;case"all":await this.clearCache("memory"),await this.clearCache("session"),await this.clearCache("local"),r.log("All caches cleared")}}clearStorageCache(e,t){try{const a=[];for(let t=0;t<e.length;t++){const n=e.key(t);n?.startsWith("translation:")&&a.push(n)}a.forEach(t=>e.removeItem(t)),r.log(`${t} cache cleared`)}catch(e){r.error(`${t} clear error:`,e)}}async getCacheStats(){return{memory:this.memoryCache.size(),session:this.getStorageCacheSize(sessionStorage),local:this.getStorageCacheSize(localStorage),hitRate:this.calculateHitRate()}}getStorageCacheSize(e){try{let t=0;for(let a=0;a<e.length;a++){const n=e.key(a);n?.startsWith("translation:")&&t++}return t}catch(e){return r.warn("Storage access error:",e),0}}calculateHitRate(){const e=this.cacheHits+this.cacheMisses;return e>0?this.cacheHits/e*100:0}chunkArray(e,t){const a=[];for(let n=0;n<e.length;n+=t)a.push(e.slice(n,n+t));return a}}var u;!function(e){e.TRANSLATE_PAGE="translate",e.TRANSLATE_SELECTION="translateSelection",e.TRANSLATE_CLIPBOARD="translateClipboard",e.REQUEST_TRANSLATION="requestTranslation",e.RESET="reset",e.TRANSLATION_STARTED="translationStarted",e.TRANSLATION_PROGRESS="translationProgress",e.TRANSLATION_COMPLETED="translationCompleted",e.TRANSLATION_ERROR="translationError",e.SELECTION_TRANSLATED="selectionTranslated",e.BATCH_COMPLETED="batchCompleted",e.SETTINGS_CHANGED="settingsChanged",e.API_KEY_UPDATED="apiKeyUpdated",e.RELOAD_CONFIG="reloadConfig",e.TEST_CONNECTION="testConnection"}(u||(u={}));class m{constructor(e,t){this.engine=e,this.client=t,this.actionHandlers=new Map([["requestTranslation",this.handleRequestTranslation.bind(this)],["clearCache",this.handleClearCache.bind(this)],["getCacheStats",this.handleGetCacheStats.bind(this)],["testConnection",this.handleTestConnection.bind(this)],["reloadConfig",this.handleReloadConfig.bind(this)]])}async handle(e,t,a){const n=(new Date).toISOString();console.log(`[Background:MessageHandler] ${n} - handle() called:`,{messageType:e.type,action:e.action,payload:e.payload,sender:{tabId:t.tab?.id,url:t.url}});try{const s=e.action||this.inferActionFromType(e.type);if(console.log(`[Background:MessageHandler] ${n} - Action resolved:`,{originalAction:e.action,inferredAction:this.inferActionFromType(e.type),finalAction:s}),!s)return console.error(`[Background:MessageHandler] ${n} - Invalid message format:`,{type:e.type,hasAction:!!e.action,message:e}),r.error("MessageHandler: Invalid message format",{type:e.type,hasAction:!!e.action,message:e}),a({success:!1,error:`Invalid message format: missing action property (type: ${e.type})`}),!0;const o=e.payload||{},i=this.actionHandlers.get(s);i?(console.log(`[Background:MessageHandler] ${n} - Routing to handler:`,{action:s,payload:o}),await i(o,a,t)):(console.error(`[Background:MessageHandler] ${n} - Unknown action:`,s),a({success:!1,error:`Unknown action: ${s}`}))}catch(e){console.error(`[Background:MessageHandler] ${n} - Unexpected error:`,{error:e,message:e instanceof Error?e.message:"Unknown error",stack:e instanceof Error?e.stack:void 0}),r.error("MessageHandler: Unexpected error",e),a({success:!1,error:e instanceof Error?e.message:"An unexpected error occurred"})}return!0}inferActionFromType(e){return{requestTranslation:"requestTranslation",testConnection:"testConnection",clearCache:"clearCache",getCacheStats:"getCacheStats"}[e]}async handleRequestTranslation(e,t,a){const n=(new Date).toISOString();console.log(`[Background:MessageHandler] ${n} - handleRequestTranslation() called:`,{payload:e,sender:{tabId:a?.tab?.id,url:a?.url}});try{const{texts:r,targetLanguage:s,semiParallel:o,priorityCount:i,phase:c}=e;if(console.log(`[Background:MessageHandler] ${n} - Validating payload:`,{hasTexts:!!r,isArray:Array.isArray(r),textsCount:Array.isArray(r)?r.length:0,targetLanguage:s,semiParallel:o,priorityCount:i}),!r||!Array.isArray(r))return console.error(`[Background:MessageHandler] ${n} - Invalid payload: texts must be an array`),void t({success:!1,error:"Invalid payload: texts must be an array"});if(!s)return console.error(`[Background:MessageHandler] ${n} - Invalid payload: targetLanguage is required`),void t({success:!1,error:"Invalid payload: targetLanguage is required"});let l;if(o&&a?.tab?.id){const e=a.tab.id,t=Math.ceil(r.length/100);let s=0;const o=c||1;l=(a,r,i)=>{s++;const c=Math.round(s/t*100);console.log(`[Background:MessageHandler] ${n} - Batch ${a} completed, sending BATCH_COMPLETED:`,{tabId:e,batchIndex:a,translationsCount:r.length,nodeIndices:i,phase:o,progress:{current:s,total:t,percentage:c}});try{chrome.tabs.sendMessage(e,{type:u.BATCH_COMPLETED,payload:{batchIndex:a,translations:r,nodeIndices:i,phase:o,progress:{current:s,total:t,percentage:c}}})}catch(t){console.error(`[Background:MessageHandler] Failed to send BATCH_COMPLETED to tab ${e}:`,t)}}}console.log(`[Background:MessageHandler] ${n} - Calling TranslationEngine.translateBatch():`,{textsCount:r.length,targetLanguage:s,semiParallel:o||!1,priorityCount:i||void 0,hasBatchCallback:!!l,firstText:r[0]?.substring(0,50)});const g=o?await this.engine.translateBatchSemiParallel(r,s,i||1,l):await this.engine.translateBatch(r,s);console.log(`[Background:MessageHandler] ${n} - Translation successful:`,{translationsCount:g.length,firstTranslation:g[0]?.substring(0,50)}),t({success:!0,data:{translations:g}})}catch(e){console.error(`[Background:MessageHandler] ${n} - Translation error:`,{error:e,message:e instanceof Error?e.message:"Unknown error",stack:e instanceof Error?e.stack:void 0}),r.error("MessageHandler: Translation error",e),t({success:!1,error:e instanceof Error?e.message:"Translation failed"})}}async handleClearCache(e,t,a){try{const a=e.layer||"all";await this.engine.clearCache(a),t({success:!0,data:{message:"Cache cleared successfully"}})}catch(e){r.error("MessageHandler: Clear cache error",e),t({success:!1,error:e instanceof Error?e.message:"Failed to clear cache"})}}async handleGetCacheStats(e,t,a){try{t({success:!0,data:await this.engine.getCacheStats()})}catch(e){r.error("MessageHandler: Get cache stats error",e),t({success:!1,error:e instanceof Error?e.message:"Failed to get cache stats"})}}async handleTestConnection(e,t,a){try{let a;a=void 0!==e?.apiKey?await this.client.testConnectionWithConfig({apiKey:e.apiKey||"",model:e.model||"",provider:e.provider}):await this.client.testConnection(),t({success:!0,data:a})}catch(e){r.error("MessageHandler: Test connection error",e),t({success:!1,error:e instanceof Error?e.message:"Connection test failed"})}}async handleReloadConfig(e,t,a){try{console.log("[MessageHandler] Reloading OpenRouterClient config..."),await this.client.initialize(),console.log("[MessageHandler] Config reloaded successfully"),t({success:!0,data:{message:"Configuration reloaded successfully"}})}catch(e){console.error("[MessageHandler] Failed to reload config:",e),t({success:!1,error:e instanceof Error?e.message:"Failed to reload config"})}}}class p{constructor(e,t="ja"){this.messageBus=e,this.targetLanguage=t,this.commandHandlers=new Map([["translate-page",this.sendTranslatePageMessage.bind(this)],["translate-selection",this.sendTranslateSelectionMessage.bind(this)],["translate-clipboard",this.sendTranslateClipboardMessage.bind(this)]])}async handle(t,a){try{let n=a;if(!n){const t=await e.tabs.query({active:!0,currentWindow:!0});if(0===t.length)return void r.warn("CommandHandler: No active tab found");n=t[0]}if(!n.id)return void r.warn("CommandHandler: Active tab has no id");const s=this.commandHandlers.get(t);s?await s(n.id):r.warn("CommandHandler: Unknown command",t)}catch(e){r.error("CommandHandler: Error handling command",e)}}async handleMessage(e,t){const a=(new Date).toISOString();console.log(`[Background:CommandHandler] ${a} - handleMessage() called:`,{messageType:e.type,tabId:t,payload:e.payload});try{let n;switch(e.type){case u.TRANSLATE_PAGE:console.log(`[Background:CommandHandler] ${a} - Routing TRANSLATE_PAGE to tab ${t}`),n=await this.sendTranslatePageMessage(t);break;case u.TRANSLATE_SELECTION:console.log(`[Background:CommandHandler] ${a} - Routing TRANSLATE_SELECTION to tab ${t}`),n=await this.sendTranslateSelectionMessage(t);break;case u.TRANSLATE_CLIPBOARD:console.log(`[Background:CommandHandler] ${a} - Routing TRANSLATE_CLIPBOARD to tab ${t}`),n=await this.sendTranslateClipboardMessage(t);break;default:return console.warn(`[Background:CommandHandler] ${a} - Unknown message type:`,e.type),r.warn("CommandHandler: Unknown message type",e.type),{success:!1,error:`Unknown message type: ${e.type}`}}return console.log(`[Background:CommandHandler] ${a} - Message sent successfully to tab ${t}`,n),n}catch(e){return console.error(`[Background:CommandHandler] ${a} - Error handling message:`,{error:e,message:e instanceof Error?e.message:"Unknown error",stack:e instanceof Error?e.stack:void 0}),r.error("CommandHandler: Error handling message",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async sendTranslatePageMessage(e){const t=(new Date).toISOString(),n=new a,s=await n.getTargetLanguage();console.log(`[Background:CommandHandler] ${t} - sendTranslatePageMessage() - Preparing message:`,{tabId:e,targetLanguage:s});try{const a={type:u.TRANSLATE_PAGE,payload:{targetLanguage:s}};console.log(`[Background:CommandHandler] ${t} - Sending to tab via MessageBus:`,{tabId:e,message:a});const n=await this.messageBus.sendToTab(e,a);return console.log(`[Background:CommandHandler] ${t} - Message sent successfully to tab ${e}`,n),n||{success:!0}}catch(a){return console.error(`[Background:CommandHandler] ${t} - Failed to send message:`,{error:a,message:a instanceof Error?a.message:"Unknown error",stack:a instanceof Error?a.stack:void 0,tabId:e}),r.error("CommandHandler: Failed to send message",a),{success:!1,error:a instanceof Error?a.message:"Unknown error"}}}async sendTranslateSelectionMessage(e){try{const t=new a,n=await t.getTargetLanguage();return await this.messageBus.sendToTab(e,{type:u.TRANSLATE_SELECTION,payload:{targetLanguage:n}})||{success:!0}}catch(e){return r.error("CommandHandler: Failed to send message",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async sendTranslateClipboardMessage(e){try{const t=new a,n=await t.getTargetLanguage();return await this.messageBus.sendToTab(e,{type:u.TRANSLATE_CLIPBOARD,payload:{targetLanguage:n}})||{success:!0}}catch(e){return r.error("CommandHandler: Failed to send message",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}}class y{constructor(){this.listeners=new Map}async send(t){const a={...t,timestamp:t.timestamp||Date.now()};return e.runtime.sendMessage(a)}async sendToTab(t,a){const n={...a,timestamp:a.timestamp||Date.now()};return e.tabs.sendMessage(t,n)}listen(t,a){const n=(e,n,r)=>(!a||e.type===a)&&(t(e,n,r)||!1);this.listeners.set(t,n),e.runtime.onMessage.addListener(n)}unlisten(t){const a=this.listeners.get(t);a&&(e.runtime.onMessage.removeListener(a),this.listeners.delete(t))}}new y,(new class{constructor(){this.messageHandler=null,this.commandHandler=null,this.engine=null,this.client=null,this.messageBus=new y}async start(){try{if(r.log("BackgroundService (Firefox): Starting..."),this.engine=new d,await this.engine.initialize(),this.client=this.engine.apiClient,!this.client)throw new Error("Failed to initialize OpenRouterClient");this.messageHandler=new m(this.engine,this.client),this.commandHandler=new p(this.messageBus),this.setupMessageListener(),this.setupCommandListener(),r.log("BackgroundService (Firefox): Started successfully")}catch(e){r.error("BackgroundService (Firefox): Failed to start",e)}}setupMessageListener(){browser.runtime.onMessage.addListener(async(e,t)=>{const a=(new Date).toISOString();if(console.log(`[Background:Firefox] ${a} - Received message:`,{type:e.type,typeOf:typeof e.type,typeValue:e.type,action:e.action,payload:e.payload,sender:{tabId:t.tab?.id,url:t.url,frameId:t.frameId}}),e.type===u.SELECTION_TRANSLATED){console.log(`[Background:Firefox] ${a} - SELECTION_TRANSLATED received, saving to session storage`);try{return await browser.storage.session.set({lastSelectionTranslation:e.payload}),console.log(`[Background:Firefox] ${a} - Successfully saved to session storage:`,{originalText:e.payload.originalText?.substring(0,50),translatedText:e.payload.translatedText?.substring(0,50),targetLanguage:e.payload.targetLanguage,timestamp:e.payload.timestamp}),{success:!0}}catch(e){return console.error(`[Background:Firefox] ${a} - Failed to save to session storage:`,e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}if(e.type===u.TRANSLATE_PAGE||e.type===u.TRANSLATE_SELECTION||e.type===u.TRANSLATE_CLIPBOARD){let n=t.tab?.id;if(!n)try{const e=await browser.tabs.query({active:!0,currentWindow:!0});n=e[0]?.id,console.log(`[Background:Firefox] ${a} - Resolved active tab ID:`,n)}catch(e){console.error(`[Background:Firefox] ${a} - Failed to get active tab:`,e)}if(console.log(`[Background:Firefox] ${a} - Routing to CommandHandler:`,{messageType:e.type,tabId:n}),!this.commandHandler||!n)return console.error(`[Background:Firefox] ${a} - Cannot route to CommandHandler:`,{hasHandler:!!this.commandHandler,hasTabId:!!n}),{success:!1,error:"CommandHandler not available or tab ID missing"};try{const t=await this.commandHandler.handleMessage(e,n);return console.log(`[Background:Firefox] ${a} - CommandHandler response:`,t),{status:"started",...t}}catch(e){return console.error(`[Background:Firefox] ${a} - CommandHandler error:`,e),{status:"error",success:!1,error:e instanceof Error?e.message:"Unknown error"}}}if(console.log(`[Background:Firefox] ${a} - Routing to MessageHandler:`,{messageType:e.type,action:e.action}),this.messageHandler)return new Promise(a=>{this.messageHandler.handle(e,t,e=>{a(e)})});console.warn(`[Background:Firefox] ${a} - No handler available for message:`,e)}),r.log("BackgroundService (Firefox): Message listener registered")}setupCommandListener(){browser.commands.onCommand.addListener(e=>{this.commandHandler&&browser.tabs.query({active:!0,currentWindow:!0}).then(t=>{t[0]&&this.commandHandler.handle(e,t[0])})}),r.log("BackgroundService (Firefox): Command listener registered")}}).start()})();